
	// insure that the slerp takes us over the top, and doesn't invert us
	Matrix slerp_test;
	TestInterporlator(&slerp_test, 0.5f);
	Matrix slerp_test2;
	if (!hip_transfer && slerp_test.m[Y][Y] < 0.937f) [[unlikely]]
	{
		if (slerp_test.m[Y][Y] < 0.0f)
		  _printf("NEGATIVE ");
		
	
		

	Slerp::axis[X] = -normal_diff[Z];// /= slerp_test.m[Y][Y] / 0.937f; //0.74706510138740661686232657417289f;
	Slerp::axis[Z] = normal_diff[X];// *= slerp_test.m[Y][Y] / 0.937f * 0.5f;// 0.74706510138740661686232657417289f;
	_printf("inverting skater %f %f\n", Slerp::axis[Z], Slerp::axis[X]);
	//(*(Vertex*)&(Slerp::axis)).Normalize();
		/*Slerp::axis[X] = -normal_diff[Z]; 
		Slerp::axis[Z] = -normal_diff[X];*/
		/*Slerp::axis[X] = normal_diff[Z];
		Slerp::axis[Z] = -normal_diff[X];*/
		/*Slerp::axis = -Slerp::axis;
		Slerp::radians = (2.0f * D3DX_PI) - Slerp::radians;*/
		TestInterporlator(&slerp_test2, 0.5f);
	}
	else
		slerp_test2 = slerp_test;


	if (slerp_test2.m[Y][Y] < 0.0f) [[unlikely]]
	{
		_printf("inverting skater, again\n");
	/*Slerp::axis[X] = normal_diff[Z];
	Slerp::axis[Z] = -normal_diff[X];*/
	Slerp::axis = -Slerp::axis;
	Slerp::radians = (2.0f * D3DX_PI) - Slerp::radians;
	/*Slerp::axis[X] = -normal_diff[X];
	Slerp::axis[Z] = -normal_diff[Z];*/
	}
	else if (slerp_test2.m[Y][Y] < 0.5f) [[unlikely]]
	{
		_printf("Setting back to normal\n");
		Slerp::axis[X] = normal_diff[Z];
		Slerp::axis[Z] = -normal_diff[X];
	}

	_printf("test_angle %f %f %f\n", slerp_test.m[Y][X], slerp_test.m[Y][Y], slerp_test.m[Y][Z]);
	_printf("test_angle2 %f %f %f\n", slerp_test2.m[Y][X], slerp_test2.m[Y][Y], slerp_test2.m[Y][Z]);